<?php
namespace initvector\Tater;

class Totp {

    /**
     * Algorithm slug, available on the system and compatible with hash_hmac.
     * @var string
     */
    protected $algorithm = 'sha1';

    /**
     * Object representing the configured epoch.
     * @var DateTime
     */
    protected $epoch;

    /**
     * Interval for determining the number of steps between the configured epoch
     * and the target password time.
     * @var int
     */
    protected $interval = 30;

    /**
     * Secret key used to hash the step count with hash_hmac.
     * @var string
     */
    protected $secretKey = '';

    /**
     * Target length for the computed token.
     * @var int
     */
    protected $tokenLength = 6;

    /**
     * Construct our TOTP object
     *
     * @param string $secretKey Secret key to be used with hash_hmac.
     * @param array $options A list of configuration directives.
     */
    public function __construct($secretKey, $options = false) {
        // Stash secret key
        $this->secretKey = $secretKey;

        // Default epoch: Unix epoch
        $epochTime = '1970-01-01 00:00:00';

        // Handling assigning configuration options to object
        if (is_array($options)) {
            if (array_key_exists('algorithm', $options)) {
                $this->algorithm = $options['algorithm'];
            }
            if (array_key_exists('interval', $options)) {
                $this->interval = (int)$options['interval'];
            }
            if (array_key_exists('tokenLength', $options)) {
                $this->tokenLength = (int)$options['tokenLength'];
            }
            if (array_key_exists('epoch', $options)) {
                $epochTime = $options['epoch'];
            }
        }

        // Instantiating epoch DateTime for calculating steps
        $this->epoch = strtotime($epochTime);
    }

    /**
     * Generate the secure token based on the provided time string.
     *
     * @param string $time A DateTime-compatible string for specifying a time.
     * @return int The number token generated by the algorithm, zero-padded
     */
    public function generate($dateTime = false) {
        if ($dateTime) {
            $dateTimeInSeconds = strtotime($dateTime);
        } else {
            $dateTimeInSeconds = time();
        }

        // Calculate seconds between configured epoch and now.
        $secondsSinceEpoch = $dateTimeInSeconds - $this->epoch;

        /**
         * Calculate number of time steps between the initial counter time
         * and the current Unix time.  The value must be stored in a 64bit
         * integer.
         */
        $steps = floor($secondsSinceEpoch/$this->interval);
        $steps = $this->getIntAs64Bits($steps);

        // Hash message with configured algorithm.
        $hash = hash_hmac($this->algorithm, $steps, $this->secretKey);

        /**
         * Grab the offset by pulling the lower four bits from the hash and
         * converting to an integer value.  Since we're emulating dealing with
         * this has hex bytes, we double the count to make sure we hit the right
         * pair value in the hash.
         */
        $offset = (hexdec(substr($hash, -2)) & 0xf) * 2;

        /**
         * Starting from the offset, grab the next 4 hex bytes (8 characters),
         * apply the proper bit mask to remove highest bit and avoid signed
         * integer confusion, convert the value to an integer, then truncate the
         * resulting integer to the configured length.
         */
        $integer = hexdec(substr($hash, $offset, 8)) & 0x7FFFFFFF;
        $integer = $integer % pow(10, $this->tokenLength);

        // Pad the value out, if necessary.
        return str_pad($integer, $this->tokenLength, 0, STR_PAD_LEFT);
    }

    /**
     * Convert incoming integer value to 64bit binary string.  If it's 32bit,
     * it will be padded to 64bits.  If it's already 64bits, it'll be unchanged.
     *
     * @param int $integer Integer value to convert
     * @return int 64bit integer represented as a binary string
     */
    protected function getIntAs64Bits($integer) {
        $integer = (int)$integer;

        /**
         * If the value exceeds the maximum for a 32bit integer, we'll assume
         * it is being stored in a 64bit integer.
         */
        if ($integer > 2147483647) {
            return $integer;
        } else {
            return pack('NN', 0, $integer);
        }
    }
}
